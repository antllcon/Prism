/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./js/script.js":
/*!**********************!*\
  !*** ./js/script.js ***!
  \**********************/
/***/ (() => {

eval("const canvasWidth = 960;\r\nconst canvasHeight = 540;\r\nconst red = \"#FC0000\";\r\nconst green = \"#00A86B\";\r\nconst gray = \"#666\";\r\nconst dark = \"#333\";\r\nconst black = \"#111\";\r\nconst laserWidth = 200;\r\nconst GAME_STATES = {\r\n    START: \"start\",\r\n    PLAY: \"play\",\r\n    VICTORY: \"victory\",\r\n    PAUSE: \"pause\"\r\n}\r\nconst PLAYER_STATES = {\r\n    ACTIVE: 'active',\r\n    STUNNED: 'stunned',\r\n    DEAD: 'dead'\r\n}\r\nconst POINT_STATES = {\r\n    ACTIVE: 'active',\r\n    INACTIVE: 'inactive'\r\n};\r\nconst DEFAULT_POINTS = [\r\n    {\r\n        x: canvasWidth / 2,\r\n        y: 10,\r\n        width: 10,\r\n        height: 10,\r\n        size: 1000,\r\n        type: 3,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth / 2,\r\n        y: canvasHeight - 10,\r\n        width: 10,\r\n        height: 10,\r\n        size: 1000,\r\n        type: 3,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth / 4,\r\n        y: canvasHeight / 2,\r\n        width: 10,\r\n        height: 10,\r\n        size: 200,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth / 4 * 3,\r\n        y: canvasHeight / 2,\r\n        width: 10,\r\n        height: 10,\r\n        size: 200,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth / 2,\r\n        y: canvasHeight / 2,\r\n        width: 10,\r\n        height: 10,\r\n        size: 1000,\r\n        type: 1,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth * (1 / 5),\r\n        y: canvasHeight - laserWidth / 2 - 20,\r\n        width: 10,\r\n        height: 10,\r\n        size: 300,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth * (2 / 5),\r\n        y: canvasHeight - laserWidth / 2 - 20,\r\n        width: 10,\r\n        height: 10,\r\n        size: 300,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth * (3 / 5),\r\n        y: canvasHeight - laserWidth / 2 - 20,\r\n        width: 10,\r\n        height: 10,\r\n        size: 300,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth * (4 / 5),\r\n        y: canvasHeight - laserWidth / 2 - 20,\r\n        width: 10,\r\n        height: 10,\r\n        size: 300,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth * (1 / 5),\r\n        y: laserWidth / 2 + 20,\r\n        width: 10,\r\n        height: 10,\r\n        size: 300,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth * (2 / 5),\r\n        y: laserWidth / 2 + 20,\r\n        width: 10,\r\n        height: 10,\r\n        size: 300,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth * (3 / 5),\r\n        y: laserWidth / 2 + 20,\r\n        width: 10,\r\n        height: 10,\r\n        size: 300,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n    {\r\n        x: canvasWidth * (4 / 5),\r\n        y: laserWidth / 2 + 20,\r\n        width: 10,\r\n        height: 10,\r\n        size: 300,\r\n        type: 2,\r\n        team: 0,\r\n        color: gray,\r\n        angle: 1,\r\n        existTime: 10000,\r\n        state: POINT_STATES.INACTIVE\r\n    },\r\n];\r\n\r\nlet canvas = document.getElementById(\"canvas\");\r\nlet gameTime = 0;\r\nlet lastTime;\r\nconst botStartX = canvasWidth - 50;\r\nconst botStartY = canvasHeight / 2;\r\nconst playerStartX = 50;\r\nconst playerStartY = canvasHeight / 2;\r\n\r\nlet GAME = {\r\n    width: canvasWidth,\r\n    height: canvasHeight,\r\n    background: dark,\r\n    state: GAME_STATES.PLAY\r\n};\r\nlet PLAYER = {\r\n    x: 30,\r\n    y: 30,\r\n    size: 10,\r\n    speed: 200,\r\n    team: 1,\r\n    color: black,\r\n    state: PLAYER_STATES.ACTIVE\r\n};\r\n\r\nlet BOT = {\r\n    x: 0,\r\n    y: 0,\r\n    size: 10,\r\n    color: 'red',\r\n    speed: 200,\r\n    team: 'red',\r\n    isAlive: true,\r\n    side: 'enemy'\r\n}\r\n\r\nlet POINTS = DEFAULT_POINTS.map(createPoint);\r\n\r\nfunction createPoint(point) {\r\n    return {\r\n        x: point.x,\r\n        y: point.y,\r\n        width: point.width,\r\n        height: point.height,\r\n        size: point.size,\r\n        type: point.type,\r\n        team: point.team,\r\n        color: point.color,\r\n        angle: point.angle,\r\n        existTime: point.existTime,\r\n        activationTime: null,\r\n        state: point.state,\r\n    };\r\n}\r\n\r\nfunction resetPoint(point, index) {\r\n    const defaultPoint = DEFAULT_POINTS[index];\r\n    point.x = defaultPoint.x;\r\n    point.y = defaultPoint.y;\r\n    point.width = defaultPoint.width;\r\n    point.height = defaultPoint.height;\r\n    point.size = defaultPoint.size;\r\n    point.type = defaultPoint.type;\r\n    point.team = defaultPoint.team;\r\n    point.color = defaultPoint.color;\r\n    point.existTime = defaultPoint.existTime;\r\n    point.activationTime = null;\r\n    point.state = POINT_STATES.INACTIVE;\r\n}\r\n\r\nlet ctx = canvas.getContext(\"2d\");\r\n\r\ncanvas.width = GAME.width;\r\ncanvas.height = GAME.height;\r\n\r\nfunction drawBackground() {\r\n    ctx.fillStyle = GAME.background;\r\n    ctx.fillRect(0, 0, GAME.width, GAME.height);\r\n}\r\n\r\nfunction drawBot() {\r\n    if (BOT.isAlive) {\r\n        ctx.fillStyle = BOT.color;\r\n        ctx.fillRect(BOT.x, BOT.y, BOT.size, BOT.size);\r\n    }\r\n    if (!BOT.isAlive) {\r\n        setTimeout(() => {\r\n            BOT.color = 'red';\r\n            BOT.x = botStartX;\r\n            BOT.y = botStartY;\r\n            BOT.isAlive = true;\r\n        }, 1000)\r\n    }\r\n}\r\n\r\nfunction drawPlayer() {\r\n    if (PLAYER.state === PLAYER_STATES.ACTIVE) {\r\n        if (PLAYER.team === 1) {\r\n            PLAYER.color = green;\r\n        }\r\n        if (PLAYER.team === 2) {\r\n            PLAYER.color = red;\r\n        }\r\n        ctx.fillStyle = PLAYER.color;\r\n        ctx.fillRect(PLAYER.x, PLAYER.y, PLAYER.size, PLAYER.size);\r\n    }\r\n    if (PLAYER.state === PLAYER_STATES.DEAD) {\r\n        setTimeout(() => {\r\n            PLAYER.color = green;\r\n            PLAYER.x = 10;\r\n            PLAYER.y = 10;\r\n            PLAYER.state = PLAYER_STATES.ACTIVE;\r\n        }, 1000); // Changed delay to 1000ms\r\n    }\r\n\r\n\r\n}\r\n\r\nfunction drawPoints() {\r\n    POINTS.forEach(point => {\r\n        if (point.state === POINT_STATES.ACTIVE) {\r\n            if (point.type === 1) {\r\n                point.angle += Math.PI / 180;\r\n                ctx.save();\r\n\r\n                ctx.translate(point.x, point.y);\r\n                ctx.rotate(point.angle);\r\n                ctx.strokeStyle = point.color;\r\n                ctx.lineWidth = 5;\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(-point.size / 2, 0);\r\n                ctx.lineTo(point.size / 2, 0);\r\n\r\n                ctx.moveTo(0, -point.size / 2);\r\n                ctx.lineTo(0, point.size / 2);\r\n                ctx.stroke();\r\n\r\n                ctx.restore();\r\n            }\r\n            if (point.type === 2) {\r\n                point.angle += Math.PI / 180;\r\n                ctx.save();\r\n\r\n                ctx.translate(point.x, point.y);\r\n                ctx.rotate(point.angle);\r\n                ctx.strokeStyle = point.color;\r\n                ctx.lineWidth = 5;\r\n\r\n                ctx.beginPath();\r\n                ctx.moveTo(point.size / 2, 0);\r\n                ctx.lineTo(0, 0);\r\n\r\n                ctx.moveTo(0, 0);\r\n                ctx.lineTo(-point.size / 2 * Math.cos(Math.PI / 3), -point.size / 2 * Math.sin(Math.PI / 3));\r\n\r\n                ctx.moveTo(0, 0);\r\n                ctx.lineTo(-point.size / 2 * Math.cos(-Math.PI / 3), -point.size / 2 * Math.sin(-Math.PI / 3));\r\n                ctx.stroke();\r\n\r\n                ctx.restore();\r\n            }\r\n            if (point.type === 3) {\r\n                ctx.save();\r\n\r\n                ctx.translate(point.x, point.y);\r\n                ctx.strokeStyle = point.color;\r\n                ctx.lineWidth = 5;\r\n                ctx.beginPath();\r\n                ctx.moveTo(point.size, 0);\r\n                ctx.lineTo(-point.size, 0);\r\n                ctx.stroke();\r\n\r\n                ctx.restore();\r\n            }\r\n\r\n        } else {\r\n            point.angle += Math.PI / 180;\r\n            ctx.save();\r\n            ctx.translate(point.x + point.width / 2, point.y + point.height / 2);\r\n            ctx.rotate(point.angle);\r\n            ctx.fillStyle = point.color;\r\n            ctx.fillRect(-point.width / 2, -point.height / 2, point.width, point.height);\r\n            ctx.restore();\r\n        }\r\n    });\r\n}\r\n\r\nfunction render() {\r\n    ctx.clearRect(0, 0, GAME.width, GAME.height);\r\n    drawBackground();\r\n    drawPoints();\r\n    drawPlayer();\r\n    drawBot();\r\n}\r\n\r\nfunction init() {\r\n    cordInit();\r\n    drawBackground();\r\n    drawPoints();\r\n    drawPlayer();\r\n    drawBot();\r\n    lastTime = Date.now();\r\n    main();\r\n}\r\n\r\nfunction cordInit() {\r\n    PLAYER.x = playerStartX;\r\n    PLAYER.y = playerStartY;\r\n    BOT.x = botStartX;\r\n    BOT.y = botStartY;\r\n    console.log(BOT.x, BOT.y);\r\n}\r\n\r\n// Основной цикл\r\nfunction main() {\r\n    let now = Date.now();\r\n    let dt = (now - lastTime) / 1000.0;\r\n    update(dt);\r\n    render();\r\n    lastTime = now;\r\n    requestAnimFrame(main);\r\n}\r\n\r\nfunction update(dt) {\r\n    gameTime += dt;\r\n    botMovement(dt);\r\n    handleInput(dt);\r\n    checkCollisions();\r\n    updateEntities();\r\n}\r\n\r\nfunction botMovement(dt) {\r\n    let loopIndexInactive = 0;\r\n    let loopIndexActive = 0;\r\n    let idInactive;\r\n    let dxMinInactive = Infinity;\r\n    let dyMinInactive = Infinity;\r\n    let hypMinInactive = Infinity;\r\n\r\n    let idActive;\r\n    let dxMinActive = Infinity;\r\n    let dyMinActive = Infinity;\r\n    let hypMinActive = Infinity;\r\n    let inRangeOfLaser = false;\r\n\r\n    findNearestPoint(POINTS);\r\n    if (inRangeOfLaser) {\r\n        moveBotOutOfLaserSpiral();\r\n    } else {\r\n        moveBotToLaser();\r\n    }\r\n    getRightDirection();\r\n\r\n    function findNearestPoint(POINTS) {\r\n        POINTS.forEach(point => {\r\n            findInactivePointAndCompare(point);\r\n            findActivePointInArea(point);\r\n        });\r\n    }\r\n\r\n    function findInactivePointAndCompare(point) {\r\n        if (point.state === POINT_STATES.INACTIVE) {\r\n            let dx = point.x - BOT.x;\r\n            let dy = point.y - BOT.y;\r\n            let hyp = Math.sqrt(dx ** 2 + dy ** 2);\r\n\r\n            if (hyp < hypMinInactive) {\r\n                idInactive = point.id;\r\n                dxMinInactive = dx;\r\n                dyMinInactive = dy;\r\n                hypMinInactive = hyp;\r\n            }\r\n            loopIndexInactive++;\r\n        }\r\n    }\r\n\r\n\r\n    function findActivePointInArea(point) {\r\n        if (point.state === POINT_STATES.ACTIVE) {\r\n            let dx = point.x - BOT.x;\r\n            let dy = point.y - BOT.y;\r\n            let hyp = Math.sqrt(dx ** 2 + dy ** 2);\r\n\r\n            if (hyp < hypMinActive) {\r\n                idActive = point.id;\r\n                dxMinActive = dx;\r\n                dyMinActive = dy;\r\n                hypMinActive = hyp;\r\n            }\r\n            inRangeOfLaser = (hypMinActive - BOT.size * Math.sqrt(2) < point.size / 2);\r\n            loopIndexActive++;\r\n        }\r\n    }\r\n\r\n    function moveBotToLaser() {\r\n        if (!isNaN(hypMinInactive) && hypMinInactive !== 0) {\r\n            dxInactive = BOT.speed * dxMinInactive / hypMinInactive * dt;\r\n            dyInactive = BOT.speed * dyMinInactive / hypMinInactive * dt;\r\n        } else {\r\n            dxInactive = 0;\r\n            dyInactive = 0;\r\n        }\r\n    }\r\n\r\n    function moveBotOutOfLaserSpiral() {\r\n        if (!isNaN(hypMinActive) && hypMinActive !== 0) {\r\n            const angle = Math.atan2(dyMinActive, dxMinActive);\r\n            const radialSpeed = BOT.speed * dt;\r\n            const angularSpeed = BOT.speed * dt / hypMinActive;\r\n\r\n            dxActive = angularSpeed * Math.sin(angle) * hypMinActive - radialSpeed * Math.cos(angle);\r\n            dyActive = (-1) * (radialSpeed * Math.sin(angle) + angularSpeed * Math.cos(angle) * hypMinActive);\r\n        } else {\r\n            dxActive = 0;\r\n            dyActive = 0;\r\n        }\r\n    }\r\n\r\n    function getRightDirection() {\r\n        if (inRangeOfLaser) {\r\n            if ((dxActive * dxInactive >= 0) && (dyActive * dyInactive >= 0)) {\r\n                if (Math.sqrt((dxActive + dxInactive) ** 2 + (dyActive + dyInactive) ** 2) < BOT.speed * dt) {\r\n                    BOT.x += dxActive + dxInactive;\r\n                    BOT.y += dyActive + dyInactive;\r\n                } else {\r\n                    const angle = Math.atan2(dyActive + dyInactive, dxActive + dxInactive);\r\n                    BOT.x += BOT.speed * dt * Math.cos(angle);\r\n                    BOT.y += BOT.speed * dt * Math.sin(angle);\r\n                }\r\n            } else if ((dxActive * dxInactive >= 0) && (dyActive * dyInactive < 0)) {\r\n                if (Math.sqrt((dxActive + dxInactive) ** 2 + dyActive ** 2) < BOT.speed * dt) {\r\n                    BOT.x += dxActive + dxInactive;\r\n                    BOT.y += dyActive;\r\n                } else {\r\n                    const angle = Math.atan2(dyActive, dxActive + dxInactive);\r\n                    BOT.x += BOT.speed * dt * Math.cos(angle);\r\n                    BOT.y += BOT.speed * dt * Math.sin(angle);\r\n                }\r\n            } else if ((dxActive * dxInactive < 0) && (dyActive * dyInactive >= 0)) {\r\n                if (Math.sqrt(dxActive ** 2 + (dyActive + dyInactive) ** 2) < BOT.speed * dt) {\r\n                    BOT.x += dxActive;\r\n                    BOT.y += dyActive + dyInactive;\r\n                } else {\r\n                    const angle = Math.atan2(dyActive + dyInactive, dxActive);\r\n                    BOT.x += BOT.speed * dt * Math.cos(angle);\r\n                    BOT.y += BOT.speed * dt * Math.sin(angle);\r\n                }\r\n            } else if ((dxActive * dxInactive < 0) && (dyActive * dyInactive < 0)) {\r\n                if (Math.sqrt(dxActive ** 2 + dyActive ** 2) < BOT.speed * dt) {\r\n                    BOT.x += dxActive;\r\n                    BOT.y += dyActive;\r\n                } else {\r\n                    const angle = Math.atan2(dyActive, dxActive);\r\n                    BOT.x += BOT.speed * dt * Math.cos(angle);\r\n                    BOT.y += BOT.speed * dt * Math.sin(angle);\r\n                }\r\n            }\r\n        } else {\r\n            BOT.x += dxInactive;\r\n            BOT.y += dyInactive;\r\n        }\r\n        if (isNaN(BOT.x) || isNaN(BOT.y)) {\r\n            console.error('BOT coordinates became NaN:', {dxInactive, dyInactive, dxActive, dyActive, hypMinInactive, hypMinActive});\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// Обработка нажатой клавиши\r\nfunction handleInput(dt) {\r\n    if (input.isDown('LEFT') || input.isDown('a')) {\r\n        PLAYER.x -= PLAYER.speed * dt;\r\n    }\r\n    if (input.isDown('RIGHT') || input.isDown('d')) {\r\n        PLAYER.x += PLAYER.speed * dt;\r\n    }\r\n    if (input.isDown('DOWN') || input.isDown('s')) {\r\n        PLAYER.y += PLAYER.speed * dt;\r\n    }\r\n    if (input.isDown('UP') || input.isDown('w')) {\r\n        PLAYER.y -= PLAYER.speed * dt;\r\n    }\r\n}\r\n\r\nfunction checkCollisions() {\r\n    checkBorderGameBounds();\r\n    checkLaserBounds();\r\n}\r\n\r\nfunction checkBorderGameBounds() {\r\n    // Проход через границы поля для ИГРОКА\r\n    if (PLAYER.x < 0) {\r\n        PLAYER.x = GAME.width;\r\n    } else if (PLAYER.x > GAME.width) {\r\n        PLAYER.x = 0;\r\n    }\r\n\r\n    if (PLAYER.y < 0) {\r\n        PLAYER.y = GAME.height;\r\n    } else if (PLAYER.y > GAME.height) {\r\n        PLAYER.y = 0;\r\n    }\r\n    // Проход через границы поля БОТА\r\n    if (BOT.x < 0) {\r\n        BOT.x = GAME.width;\r\n    } else if (BOT.x > GAME.width) {\r\n        BOT.x = 0;\r\n    }\r\n\r\n    if (BOT.y < 0) {\r\n        BOT.y = GAME.height;\r\n    } else if (BOT.y > GAME.height) {\r\n        BOT.y = 0;\r\n    }\r\n}\r\n\r\nfunction checkLaserBounds() {\r\n    // Перебор всех лазеров\r\n    POINTS.forEach(point => {\r\n        // считаем sin и cos для каждого угла лазера\r\n        const sin = Math.sin(point.angle);\r\n        const cos = Math.cos(point.angle);\r\n\r\n        // массив углов игрока\r\n        const playerCorners = [\r\n            {x: PLAYER.x, y: PLAYER.y},\r\n            {x: PLAYER.x + PLAYER.size, y: PLAYER.y},\r\n            {x: PLAYER.x, y: PLAYER.y + PLAYER.size},\r\n            {x: PLAYER.x + PLAYER.size, y: PLAYER.y + PLAYER.size}\r\n        ];\r\n\r\n        // проверяем каждую угловую точку игрока\r\n        for (const corner of playerCorners) {\r\n            // насчитаем удаленность угловой точки игрока от центра лазера\r\n            const dx = corner.x - point.x;\r\n            const dy = corner.y - point.y;\r\n\r\n            // переводим удаленность в систему координат вращения лазера\r\n            const rotatedX = cos * dx + sin * dy;\r\n            const rotatedY = -sin * dx + cos * dy;\r\n\r\n            // смотрим на положение, делаем выводы относительно каждого состояния лазера\r\n            // и так ищем коллизию игрока с лазером\r\n\r\n            // Если точка принимает неактивное состояние\r\n            if (point.state === POINT_STATES.INACTIVE &&\r\n                rotatedX > -point.width / 2 && rotatedX < point.width / 2 &&\r\n                rotatedY > -point.height / 2 && rotatedY < point.height / 2) {\r\n                point.state = POINT_STATES.ACTIVE;\r\n                point.team = PLAYER.team;\r\n                point.activationTime = Date.now();\r\n            }\r\n\r\n            // Проверка коллизий с лазерами\r\n            if (point.state === POINT_STATES.ACTIVE) {\r\n                if (point.type === 1 && point.team === PLAYER.team) { // Крест\r\n                    if ((Math.abs(rotatedX) < point.size / 2 && Math.abs(rotatedY) < point.width / 2) ||\r\n                        (Math.abs(rotatedY) < point.size / 2 && Math.abs(rotatedX) < point.width / 2)) {\r\n                        PLAYER.state = PLAYER_STATES.DEAD;\r\n                    }\r\n                }\r\n                if (point.type === 2 && point.team === PLAYER.team) { // Три-радиус\r\n                    const angles = [0, 2 * Math.PI / 3, -2 * Math.PI / 3]; // 0, 120, -120 углы\r\n\r\n                    angles.forEach(angle => {\r\n                        const angleSin = Math.sin(angle);\r\n                        const angleCos = Math.cos(angle);\r\n\r\n                        const rotatedRayX = angleCos * rotatedX - angleSin * rotatedY;\r\n                        const rotatedRayY = angleSin * rotatedX + angleCos * rotatedY;\r\n\r\n                        if (rotatedRayX > 0 && rotatedRayX < point.size / 2 && Math.abs(rotatedRayY) < point.height / 2) {\r\n                            PLAYER.state = PLAYER_STATES.DEAD;\r\n                        }\r\n                    });\r\n                }\r\n                if (point.type === 3 && point.team === PLAYER.team) { // Прямая линия (горизонтальная)\r\n                    if (corner.y >= point.y - point.width / 2 && corner.y <= point.y + point.width / 2 &&\r\n                        corner.x >= point.x - point.size / 2 && corner.x <= point.x + point.size / 2) {\r\n                        PLAYER.state = PLAYER_STATES.DEAD;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    });\r\n}\r\n\r\nfunction updateEntities() {\r\n    POINTS.forEach(point => {\r\n        if (point.state === POINT_STATES.ACTIVE && Date.now() - point.activationTime < point.existTime) {\r\n            if (point.team === PLAYER.team) {\r\n                point.color = PLAYER.color;\r\n                point.height = 5;\r\n            }\r\n        } else {\r\n            point.state = POINT_STATES.INACTIVE;\r\n            resetPoint(point, POINTS.indexOf(point));\r\n        }\r\n        if (PLAYER.state === POINT_STATES.DEAD) {\r\n            PLAYER.color = black;\r\n        }\r\n        if (PLAYER.state === PLAYER_STATES.STUNNED) {\r\n            PLAYER.x = 30;\r\n            PLAYER.y = 30;\r\n        }\r\n    });\r\n}\r\n\r\n\r\n// Определение requestAnimFrame\r\nwindow.requestAnimFrame = window.requestAnimationFrame || function (callback) {\r\n    window.setTimeout(callback, 1000 / 60);\r\n};\r\n\r\ninit();\r\n\r\n\n\n//# sourceURL=webpack://prism/./js/script.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = {};
/******/ 	__webpack_modules__["./js/script.js"]();
/******/ 	
/******/ })()
;